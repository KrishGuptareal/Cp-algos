struct sparseTable{
    int n,K;
    vector <vector<int>> st;
    vector<int> lg;
    inline int combine(int x,int y){
        //write your funtion here
    }
    void init(vector<int> v){
        n=v.size();
        K=log2(n)+1;
        lg.resize(n+1);
        lg[1]=0;
        for(int i=2;i<=n;i++)
            lg[i]=lg[i/2]+1;
        
        st.assign(n,vector<int> (K));
        for(int i=0;i<n;i++)
            st[i][0]=v[i];
        
        //build 
        for(int j=1;j<K;j++){
            for(int i=0;i+(1<<j)<=n;i++){
                st[i][j]=combine(st[i][j-1],st[i+(1<<(j-1))][j-1]);
            }
        }
    }
    int query(int l,int r){
        l--;r--;
        int j = lg[r - l + 1];
        return combine(st[l][j], st[r - (1<<j) + 1][j]);
    }
    int query2(int L, int R) { 
        L--;R--;
        int res = 0;               // give the base case here
        for (int j = K-1; j >= 0; j--) {
            if ((1 << j) <= R - L + 1) {
                res = combine(res, st[L][j]);
                L += (1 << j);
            }
        }
        return res;
    }
};

/*
  to initailize
  sparseTable st;
  st.init(diff);
  use query(o(1) if the overlaping is not an issue 
  else use query2(o(logn))
*/
